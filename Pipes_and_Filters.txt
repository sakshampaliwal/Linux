stdin= standard input and its signal is 0
stdout= standard output and its signal is 1
stderr= standard error and its signal is 2

echo this is saksham! > output.txt  //this command will print output on the output.txt file
zecho this is saksham! > output.txt //this will shows error and doesn’t save the output

To save the error in the file:
zecho this is saksham! 2> output.txt //now this will save error on the output.txt file
//in above command you can see i used 2 which means i am saying that we are going to save the error in the file
//by default value is 1 if we not specify it like in above cases.

>>: It is a redirection operator used for appending output to a file. 
    it tells the shell to take the standard output (stdout) of the preceding command and append it to the specified file, rather than overwriting the file. 
    If the file doesn't exist, it will be created. 
    e.g: echo "This is some text" >> myfile.txt

Noclobber: It is a shell option that helps prevent accidental overwriting of files when using output redirection operators such as > or >>. 
           When noclobber is enabled, attempting to overwrite an existing file using these operators will result in an error, 
           which can help you avoid unintentional data loss.
           Enable: set -o noclobber
           Disable: set +o noclobber
           To check it is enabled or not: echo $- //it is used to display the current shell's options and attributes, also known as the shell's "flags." 
           These flags indicate various settings and behaviors of the shell.

           echo abcd >| out.txt //It force the output to be written to the file even if noclobber (preventing file overwrite) is enabled.
           // | symbol is used to override the noclobber option if it's enabled.


/dev/null : 
- It is a special file that serve as a blackhole for data. It is often referred to as the "null device" or simply "null."
- When you write data to /dev/null, it essentially disappears and does not get stored anywhere on the system. 
  When you read from /dev/null, you will receive an immediate end-of-file (EOF) signal, indicating that there is no data to be read.
- this file has a size of 0 bytes, has zero blocks allocated to it. The file permissions are also set that anyone can read/write to it, but cannot execute it.
- Writing data to /dev/null is a way to discard information. It's commonly used to intentionally discard output that you don't need or want to see,
- For example, if you want to run a command but don't want to see its output, you can redirect the output to /dev/null.

Redirect error msg: some_command 2> /dev/null  # Redirects standard error to /dev/null
// and if output is produced then it will be displayed

Combining error and output: some_command > /dev/null 2>&1
//It combines both output streams into a single stream that goes to /dev/null whereas above command
//It leaves standard output (stdout) untouched, meaning that any output generated by some_command on stdout will still be displayed or logged. 
//It discards only error messages, not regular output.

stat filename //this command displays basic information about the specified file or dir, such as its size, permissions, and timestamps.


Greater than(<) and Less than(>) sign:
>: It is used for output redirection, specifically to redirect the standard output (stdout) of a command to a file or device.
   Used to write the output of a command to a file or to overwrite the contents of a file with the output.
   If the specified file does not exist, it will be created. If it already exists, its contents will be replaced with the new output.

<: Used for input redirection, specifically to read input from a file or device and provide it as input to a command.
   Used to take input for a command from a file rather than the keyboard.
   E.g: cat < input.txt or cat 0< input.txt  //as 0 is also for input redirect
      or cat input.txt is also same as above.

cat winter.txt > snow.txt 2>error.txt
//in this cmd winter.txt content will be redirected to snow.txt and if error comes then it will be printed in error.txt file

> filename
//this command will delete all content of file but file remains.


To reverse the content of file: tac filename.txt

tee command:
- It allows you to read from standard input and write to one or more files or to standard output simultaneously. It is often used to redirect the output of a command to a file while still displaying it on the screen.
- Syntax: [command] | tee [options] [filename]
- Options like -a(append), -i(ignore interrupt continue running even if it receives an interrupt signal (e.g., Ctrl+C).)

E.g: ls -l | tee output.txt  //tee captures the output of ls and write it in output.txt file

> grep -A2 anytext filename.txt  //A2 means after 2 lines it will show 2lines after the text.
If you write B then it will display before text line.
If you write C then it will display 2line before and after the text.

cut command:
- It allows you to cut out sections of a specified file or piped data and print the result to standard output. The command cuts parts of a line by field, delimiter, byte position, and character.
- Syntax: cut [option] [file]
- Extract specific fields based on a delimiter (by default, a tab or space character). You can specify the delimiter using the -d option. For example, to extract the second field from a comma-separated file:

E.g: > cut -d" " -f1 filename.txt  //-d will split the text into fields wherever it encounters a space character. 
-f  specifies which field to extract. In this case, it's asking for the first field. Fields are counted based on the delimiter. So, if the delimiter is a space character, the first field is the text before the first space in each line.

tr command:
- tr is short for “translate”.
- The tr command reads a byte stream from standard input (stdin), translates or deletes characters, then writes the result to the standard output (stdout).
- Syntax: tr [OPTION] SET1 [SET2]   //Set1 on which action is performed, Set2 is action that is going to perform.
- Since tr doesn’t support reading a file directly, if we want to apply it to a text file, we need to pipe the file content to tr or redirect the file to stdin.

E.g: tr 'a-z' 'A-Z' < baeldung.url  //Lowercase to Uppercase
> cat env.txt | tr '-' '_'  //Find and replace
> tr -d '0-9' < input.txt > output.txt  //deletes all digits from the input file and saves the result in the output.txt 
> echo 'Hi,   nice   to  meet            you!' | tr -s ' '   //remove repeated instances of a character 
> echo "A a B b C c" | tr -d 'a-z'  //delete all lowercase letters from the input text

